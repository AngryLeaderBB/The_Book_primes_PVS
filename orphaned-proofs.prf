("inf_prime_harmonic_prime" |inf_prime_harmonic_prime| |prime_enumeration_TCC1| 0 (|prime_enumeration_TCC1-1| NIL 3941051392 ("" (SUBTYPE-TCC) NIL NIL) ((|boolean| NONEMPTY-TYPE-DECL NIL |booleans| NIL) (|bool| NONEMPTY-TYPE-EQ-DECL NIL |booleans| NIL) (NOT CONST-DECL "[bool -> bool]" |booleans| NIL) (|number| NONEMPTY-TYPE-DECL NIL |numbers| NIL) (|number_field_pred| CONST-DECL "[number -> boolean]" |number_fields| NIL) (|number_field| NONEMPTY-TYPE-FROM-DECL NIL |number_fields| NIL) (|real_pred| CONST-DECL "[number_field -> boolean]" |reals| NIL) (|real| NONEMPTY-TYPE-FROM-DECL NIL |reals| NIL) (>= CONST-DECL "bool" |reals| NIL) (|rational_pred| CONST-DECL "[real -> boolean]" |rationals| NIL) (|rational| NONEMPTY-TYPE-FROM-DECL NIL |rationals| NIL) (|integer_pred| CONST-DECL "[rational -> boolean]" |integers| NIL) (|int| NONEMPTY-TYPE-EQ-DECL NIL |integers| NIL) (|nat| NONEMPTY-TYPE-EQ-DECL NIL |naturalnumbers| NIL) (/= CONST-DECL "boolean" |notequal| NIL) (|divides| CONST-DECL "bool" |divides| NIL) (|int_minus_int_is_int| APPLICATION-JUDGEMENT "int" |integers| NIL) (|real_ge_is_total_order| NAME-JUDGEMENT "(total_order?[real])" |real_props| NIL) (|real_gt_is_strict_total_order| NAME-JUDGEMENT "(strict_total_order?[real])" |real_props| NIL) (|prime?| CONST-DECL "bool" |primes| |ints|)) NIL (|prime_enumeration| SUBTYPE "(number_fields.-)(inf_prime_harmonic_prime.n, 1)" "nat")))("inf_prime_harmonic_prime" |inf_prime_harmonic_prime| |prime_enumeration_TCC2| 0 (|prime_enumeration_TCC2-1| NIL 3941051392 ("" (TERMINATION-TCC) NIL NIL) NIL NIL (|prime_enumeration| TERMINATION "inf_prime_harmonic_prime.prime_enumeration((number_fields.-)(inf_prime_harmonic_prime.n, 1))" "NIL")))("inf_prime_harmonic_prime" |inf_prime_harmonic_prime| |prime_enumeration_TCC3| 0 (|prime_enumeration_TCC3-1| NIL 3941446888 ("" (SUBTYPE-TCC) NIL NIL) ((|boolean| NONEMPTY-TYPE-DECL NIL |booleans| NIL) (|bool| NONEMPTY-TYPE-EQ-DECL NIL |booleans| NIL) (NOT CONST-DECL "[bool -> bool]" |booleans| NIL) (|number| NONEMPTY-TYPE-DECL NIL |numbers| NIL) (|number_field_pred| CONST-DECL "[number -> boolean]" |number_fields| NIL) (|number_field| NONEMPTY-TYPE-FROM-DECL NIL |number_fields| NIL) (|real_pred| CONST-DECL "[number_field -> boolean]" |reals| NIL) (|real| NONEMPTY-TYPE-FROM-DECL NIL |reals| NIL) (>= CONST-DECL "bool" |reals| NIL) (|rational_pred| CONST-DECL "[real -> boolean]" |rationals| NIL) (|rational| NONEMPTY-TYPE-FROM-DECL NIL |rationals| NIL) (|integer_pred| CONST-DECL "[rational -> boolean]" |integers| NIL) (|int| NONEMPTY-TYPE-EQ-DECL NIL |integers| NIL) (|nat| NONEMPTY-TYPE-EQ-DECL NIL |naturalnumbers| NIL) (/= CONST-DECL "boolean" |notequal| NIL) (|divides| CONST-DECL "bool" |divides| NIL) (|int_minus_int_is_int| APPLICATION-JUDGEMENT "int" |integers| NIL) (|real_ge_is_total_order| NAME-JUDGEMENT "(total_order?[real])" |real_props| NIL) (|real_gt_is_strict_total_order| NAME-JUDGEMENT "(strict_total_order?[real])" |real_props| NIL) (|prime?| CONST-DECL "bool" |primes| |ints|) (|member| CONST-DECL "bool" |sets| NIL) (|empty?| CONST-DECL "bool" |sets| NIL)) NIL (|prime_enumeration| SUBTYPE "(number_fields.-)(inf_prime_harmonic_prime.n, 1)" "nat")))("inf_prime_harmonic_prime" |inf_prime_harmonic_prime| |prime_enumeration_TCC4| 0 (|prime_enumeration_TCC4-1| NIL 3941446888 ("" (TERMINATION-TCC) NIL NIL) ((|member| CONST-DECL "bool" |sets| NIL) (|empty?| CONST-DECL "bool" |sets| NIL)) NIL (|prime_enumeration| TERMINATION "inf_prime_harmonic_prime.prime_enumeration((number_fields.-)(inf_prime_harmonic_prime.n, 1))" "NIL")))("inf_prime_harmonic_prime" |inf_prime_harmonic_prime| |prime_enumeration_TCC5| 0 (|prime_enumeration_TCC3-1| NIL 3941051392 ("" (SUBTYPE-TCC) NIL NIL) ((|boolean| NONEMPTY-TYPE-DECL NIL |booleans| NIL) (|bool| NONEMPTY-TYPE-EQ-DECL NIL |booleans| NIL) (NOT CONST-DECL "[bool -> bool]" |booleans| NIL) (|number| NONEMPTY-TYPE-DECL NIL |numbers| NIL) (|number_field_pred| CONST-DECL "[number -> boolean]" |number_fields| NIL) (|number_field| NONEMPTY-TYPE-FROM-DECL NIL |number_fields| NIL) (|real_pred| CONST-DECL "[number_field -> boolean]" |reals| NIL) (|real| NONEMPTY-TYPE-FROM-DECL NIL |reals| NIL) (>= CONST-DECL "bool" |reals| NIL) (|rational_pred| CONST-DECL "[real -> boolean]" |rationals| NIL) (|rational| NONEMPTY-TYPE-FROM-DECL NIL |rationals| NIL) (|integer_pred| CONST-DECL "[rational -> boolean]" |integers| NIL) (|int| NONEMPTY-TYPE-EQ-DECL NIL |integers| NIL) (|nat| NONEMPTY-TYPE-EQ-DECL NIL |naturalnumbers| NIL) (/= CONST-DECL "boolean" |notequal| NIL) (|divides| CONST-DECL "bool" |divides| NIL) (|real_gt_is_strict_total_order| NAME-JUDGEMENT "(strict_total_order?[real])" |real_props| NIL) (|real_ge_is_total_order| NAME-JUDGEMENT "(total_order?[real])" |real_props| NIL) (|int_minus_int_is_int| APPLICATION-JUDGEMENT "int" |integers| NIL) (|nonneg_int| NONEMPTY-TYPE-EQ-DECL NIL |integers| NIL) (> CONST-DECL "bool" |reals| NIL) (|posnat| NONEMPTY-TYPE-EQ-DECL NIL |integers| NIL) (|prime?| CONST-DECL "bool" |primes| |ints|) (|member| CONST-DECL "bool" |sets| NIL) (|empty?| CONST-DECL "bool" |sets| NIL)) NIL (|prime_enumeration| SUBTYPE "inf_prime_harmonic_prime.x" "nat")))("inf_prime_harmonic_prime" |inf_prime_harmonic_prime| |prime_enumeration_TCC6| 0 (|prime_enumeration_TCC4-1| NIL 3941051392 ("" (SUBTYPE-TCC) NIL NIL) ((|boolean| NONEMPTY-TYPE-DECL NIL |booleans| NIL) (|bool| NONEMPTY-TYPE-EQ-DECL NIL |booleans| NIL) (NOT CONST-DECL "[bool -> bool]" |booleans| NIL) (|number| NONEMPTY-TYPE-DECL NIL |numbers| NIL) (|number_field_pred| CONST-DECL "[number -> boolean]" |number_fields| NIL) (|number_field| NONEMPTY-TYPE-FROM-DECL NIL |number_fields| NIL) (|real_pred| CONST-DECL "[number_field -> boolean]" |reals| NIL) (|real| NONEMPTY-TYPE-FROM-DECL NIL |reals| NIL) (>= CONST-DECL "bool" |reals| NIL) (|rational_pred| CONST-DECL "[real -> boolean]" |rationals| NIL) (|rational| NONEMPTY-TYPE-FROM-DECL NIL |rationals| NIL) (|integer_pred| CONST-DECL "[rational -> boolean]" |integers| NIL) (|int| NONEMPTY-TYPE-EQ-DECL NIL |integers| NIL) (|nat| NONEMPTY-TYPE-EQ-DECL NIL |naturalnumbers| NIL) (|member| CONST-DECL "bool" |sets| NIL) (|empty?| CONST-DECL "bool" |sets| NIL) (|nonempty?| CONST-DECL "bool" |sets| NIL)) NIL (|prime_enumeration| SUBTYPE "{p: (primes.prime?) | reals.>(p, inf_prime_harmonic_prime.prime_enumeration((number_fields.-)(inf_prime_harmonic_prime.n, 1)))}" "(sets[(primes.prime?)].nonempty?)")))("inf_prime_harmonic_prime" |inf_prime_harmonic_prime| |prime_enum_tail_gen| 0 (|prime_enum_tail_gen-1| NIL 3944733812 ("" (SKEEP) (("" (MEASURE-INDUCT "k-n" "k") (("" (SKEEP) (("" (CASE-REPLACE "x = n") (("" (INST -1 "x-1") (("1" (ASSERT) (("1" (EXPAND "prime_enumeration" 2) (("1" (PROPAX) NIL NIL)) NIL)) NIL) ("2" (ASSERT) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ((|pred| TYPE-EQ-DECL NIL |defined_types| NIL) (|well_founded?| CONST-DECL "bool" |orders| NIL) (< CONST-DECL "bool" |reals| NIL) (- CONST-DECL "[numfield, numfield -> numfield]" |number_fields| NIL) (|numfield| NONEMPTY-TYPE-EQ-DECL NIL |number_fields| NIL) (|naturalnumber| TYPE-EQ-DECL NIL |naturalnumbers| NIL) (|nat| NONEMPTY-TYPE-EQ-DECL NIL |naturalnumbers| NIL) (>= CONST-DECL "bool" |reals| NIL) (|bool| NONEMPTY-TYPE-EQ-DECL NIL |booleans| NIL) (|int| NONEMPTY-TYPE-EQ-DECL NIL |integers| NIL) (|integer_pred| CONST-DECL "[rational -> boolean]" |integers| NIL) (|rational| NONEMPTY-TYPE-FROM-DECL NIL |rationals| NIL) (|rational_pred| CONST-DECL "[real -> boolean]" |rationals| NIL) (|real| NONEMPTY-TYPE-FROM-DECL NIL |reals| NIL) (|real_pred| CONST-DECL "[number_field -> boolean]" |reals| NIL) (|number_field| NONEMPTY-TYPE-FROM-DECL NIL |number_fields| NIL) (|number_field_pred| CONST-DECL "[number -> boolean]" |number_fields| NIL) (|boolean| NONEMPTY-TYPE-DECL NIL |booleans| NIL) (|number| NONEMPTY-TYPE-DECL NIL |numbers| NIL) (|measure_induction| FORMULA-DECL NIL |measure_induction| NIL) (|int_minus_int_is_int| APPLICATION-JUDGEMENT "int" |integers| NIL) (|wf_nat| FORMULA-DECL NIL |naturalnumbers| NIL) (= CONST-DECL "[T, T -> boolean]" |equalities| NIL) (|prime_enumeration| DEF-DECL "int" |inf_prime_harmonic_prime| NIL) (|minus_nzint_is_nzint| APPLICATION-JUDGEMENT "nzint" |integers| NIL) (|real_lt_is_strict_total_order| NAME-JUDGEMENT "(strict_total_order?[real])" |real_props| NIL) (AND CONST-DECL "[bool, bool -> bool]" |booleans| NIL) (|n| SKOLEM-CONST-DECL "nat" |inf_prime_harmonic_prime| NIL) (|x| SKOLEM-CONST-DECL "{k: nat | k >= n}" |inf_prime_harmonic_prime| NIL) (|real_ge_is_total_order| NAME-JUDGEMENT "(total_order?[real])" |real_props| NIL)) SHOSTAK))("inf_prime_harmonic_prime" |inf_prime_harmonic_prime| |prime_enum_zero_tail_TCC1| 0 (|prime_enum_zero_tail_TCC1-1| NIL 3941448963 ("" (SUBTYPE-TCC) NIL NIL) NIL NIL (|prime_enum_zero_tail| SUBTYPE "(number_fields.-)(inf_prime_harmonic_prime.b, 1)" "nat")))("inf_prime_harmonic_prime" |inf_prime_harmonic_prime| |prime_enum_zero_tail| 0 (|prime_enum_zero_tail-1| NIL 3941448985 ("" (PROP) (("1" (SKEEP) (("1" (CASE "FORALL(n:nat): prime_enumeration(n) = 0") (("1" (INST -1 "0") (("1" (EXPAND "prime_enumeration" -1) (("1" (ASSERT) NIL NIL)) NIL)) NIL) ("2" (MEASURE-INDUCT "IF n > a THEN 0 ELSE a-n ENDIF" "n" 1) (("1" (SKEEP) (("1" (CASE "x >= a") (("1" (INST -3 "x") NIL NIL) ("2" (INST -1 "x+1") (("2" (PROP) (("1" (EXPAND "prime_enumeration" -1) (("1" (LIFT-IF) (("1" (PROP) (("1" (INST 3 "x+1") (("1" (ASSERT) NIL NIL)) NIL) ("2" (HIDE-ALL-BUT (-1 5)) (("2" (NAME-REPLACE "m" "min({p: (prime?) | p > prime_enumeration(x)})") (("1" (TYPEPRED "m") (("1" (EXPAND "prime?") (("1" (ASSERT) NIL NIL)) NIL)) NIL) ("2" (SKOLEM 1 "z") (("2" (TYPEPRED "z") (("2" (EXPAND "prime?") (("2" (ASSERT) NIL NIL)) NIL)) NIL)) NIL) ("3" (EXPAND "nonempty?") (("3" (INST 1 "x+1") (("3" (ASSERT) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (ASSERT) NIL NIL)) NIL)) NIL)) NIL)) NIL) ("2" (SKEEP) (("2" (ASSERT) NIL NIL)) NIL)) NIL)) NIL)) NIL) ("2" (SKEEP) (("2" (INST 1 "b") (("2" (MEASURE-INDUCT "n-b" "n") (("2" (SKEEP) (("2" (CASE "x = b") (("1" (REPLACES -1) (("1" (EXPAND "prime_enumeration" 1) (("1" (LIFT-IF) (("1" (PROP) NIL NIL)) NIL)) NIL)) NIL) ("2" (INST -1 "x-1") (("1" (PROP) (("1" (EXPAND "prime_enumeration" 2) (("1" (LIFT-IF) (("1" (PROP) NIL NIL)) NIL)) NIL) ("2" (ASSERT) NIL NIL)) NIL) ("2" (ASSERT) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ((TRUE CONST-DECL "bool" |booleans| NIL) (|b| SKOLEM-CONST-DECL "posnat" |inf_prime_harmonic_prime| NIL) (|x| SKOLEM-CONST-DECL "{n: nat | n >= b}" |inf_prime_harmonic_prime| NIL) (|int_minus_int_is_int| APPLICATION-JUDGEMENT "int" |integers| NIL) (|wf_nat| FORMULA-DECL NIL |naturalnumbers| NIL) (|measure_induction| FORMULA-DECL NIL |measure_induction| NIL) (|naturalnumber| TYPE-EQ-DECL NIL |naturalnumbers| NIL) (IF CONST-DECL "[boolean, T, T -> T]" |if_def| NIL) (> CONST-DECL "bool" |reals| NIL) (|nonneg_int| NONEMPTY-TYPE-EQ-DECL NIL |integers| NIL) (|posnat| NONEMPTY-TYPE-EQ-DECL NIL |integers| NIL) (|numfield| NONEMPTY-TYPE-EQ-DECL NIL |number_fields| NIL) (- CONST-DECL "[numfield, numfield -> numfield]" |number_fields| NIL) (< CONST-DECL "bool" |reals| NIL) (NOT CONST-DECL "[bool -> bool]" |booleans| NIL) (IMPLIES CONST-DECL "[bool, bool -> bool]" |booleans| NIL) (|well_founded?| CONST-DECL "bool" |orders| NIL) (|pred| TYPE-EQ-DECL NIL |defined_types| NIL) (|x| SKOLEM-CONST-DECL "nat" |inf_prime_harmonic_prime| NIL) (|a| SKOLEM-CONST-DECL "posnat" |inf_prime_harmonic_prime| NIL) (|real_ge_is_total_order| NAME-JUDGEMENT "(total_order?[real])" |real_props| NIL) (|real_gt_is_strict_total_order| NAME-JUDGEMENT "(strict_total_order?[real])" |real_props| NIL) (|min| CONST-DECL "{a | S(a) AND (FORALL x: S(x) IMPLIES a <= x)}" |min_nat| NIL) (<= CONST-DECL "bool" |reals| NIL) (AND CONST-DECL "[bool, bool -> bool]" |booleans| NIL) (|nonempty?| CONST-DECL "bool" |sets| NIL) (|set| TYPE-EQ-DECL NIL |sets| NIL) (|prime?| CONST-DECL "bool" |primes| |ints|) (|real_lt_is_strict_total_order| NAME-JUDGEMENT "(strict_total_order?[real])" |real_props| NIL) (|minus_nzint_is_nzint| APPLICATION-JUDGEMENT "nzint" |integers| NIL) (+ CONST-DECL "[numfield, numfield -> numfield]" |number_fields| NIL) (|nnint_plus_posint_is_posint| APPLICATION-JUDGEMENT "posint" |integers| NIL) (|number| NONEMPTY-TYPE-DECL NIL |numbers| NIL) (|boolean| NONEMPTY-TYPE-DECL NIL |booleans| NIL) (|number_field_pred| CONST-DECL "[number -> boolean]" |number_fields| NIL) (|number_field| NONEMPTY-TYPE-FROM-DECL NIL |number_fields| NIL) (|real_pred| CONST-DECL "[number_field -> boolean]" |reals| NIL) (|real| NONEMPTY-TYPE-FROM-DECL NIL |reals| NIL) (|rational_pred| CONST-DECL "[real -> boolean]" |rationals| NIL) (|rational| NONEMPTY-TYPE-FROM-DECL NIL |rationals| NIL) (|integer_pred| CONST-DECL "[rational -> boolean]" |integers| NIL) (|int| NONEMPTY-TYPE-EQ-DECL NIL |integers| NIL) (|bool| NONEMPTY-TYPE-EQ-DECL NIL |booleans| NIL) (>= CONST-DECL "bool" |reals| NIL) (|nat| NONEMPTY-TYPE-EQ-DECL NIL |naturalnumbers| NIL) (= CONST-DECL "[T, T -> boolean]" |equalities| NIL) (|prime_enumeration| DEF-DECL "int" |inf_prime_harmonic_prime| NIL)) SHOSTAK))("inf_prime_harmonic_prime" |inf_prime_harmonic_prime| |prime_enum_id| 0 (|prime_enum_id-1| NIL 3944659450 ("" (MEASURE-INDUCT "n" "n") (("" (SKEEP) (("" (CASE-REPLACE "x = 0") (("1" (EXPAND "prime_enumeration") (("1" (REWRITE "prime_2") NIL NIL)) NIL) ("2" (INST -1 "x-1") (("1" (ASSERT) (("1" (PROP) (("1" (EXPAND "prime_enumeration" (2 3)) (("1" (LIFT-IF) (("1" (PROP) NIL NIL)) NIL)) NIL) ("2" (EXPAND "prime_enumeration" (2 3)) (("2" (LIFT-IF) (("2" (PROP) (("2" (ASSERT) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (ASSERT) NIL NIL)) NIL)) NIL)) NIL)) NIL) ((|real_ge_is_total_order| NAME-JUDGEMENT "(total_order?[real])" |real_props| NIL) (|int_minus_int_is_int| APPLICATION-JUDGEMENT "int" |integers| NIL) (|x| SKOLEM-CONST-DECL "nat" |inf_prime_harmonic_prime| NIL) (- CONST-DECL "[numfield, numfield -> numfield]" |number_fields| NIL) (|numfield| NONEMPTY-TYPE-EQ-DECL NIL |number_fields| NIL) (|real_lt_is_strict_total_order| NAME-JUDGEMENT "(strict_total_order?[real])" |real_props| NIL) (|prime_2| FORMULA-DECL NIL |primes| |ints|) (OR CONST-DECL "[bool, bool -> bool]" |booleans| NIL) (= CONST-DECL "[T, T -> boolean]" |equalities| NIL) (|prime_enumeration| DEF-DECL "int" |inf_prime_harmonic_prime| NIL) (|prime?| CONST-DECL "bool" |primes| |ints|) (|wf_nat| FORMULA-DECL NIL |naturalnumbers| NIL) (< CONST-DECL "bool" |reals| NIL) (|naturalnumber| TYPE-EQ-DECL NIL |naturalnumbers| NIL) (|nat| NONEMPTY-TYPE-EQ-DECL NIL |naturalnumbers| NIL) (>= CONST-DECL "bool" |reals| NIL) (|bool| NONEMPTY-TYPE-EQ-DECL NIL |booleans| NIL) (|int| NONEMPTY-TYPE-EQ-DECL NIL |integers| NIL) (|integer_pred| CONST-DECL "[rational -> boolean]" |integers| NIL) (|rational| NONEMPTY-TYPE-FROM-DECL NIL |rationals| NIL) (|rational_pred| CONST-DECL "[real -> boolean]" |rationals| NIL) (|real| NONEMPTY-TYPE-FROM-DECL NIL |reals| NIL) (|real_pred| CONST-DECL "[number_field -> boolean]" |reals| NIL) (|number_field| NONEMPTY-TYPE-FROM-DECL NIL |number_fields| NIL) (|number_field_pred| CONST-DECL "[number -> boolean]" |number_fields| NIL) (|boolean| NONEMPTY-TYPE-DECL NIL |booleans| NIL) (|number| NONEMPTY-TYPE-DECL NIL |numbers| NIL) (|measure_induction| FORMULA-DECL NIL |measure_induction| NIL) (|well_founded?| CONST-DECL "bool" |orders| NIL) (|pred| TYPE-EQ-DECL NIL |defined_types| NIL)) SHOSTAK))("inf_prime_harmonic_prime" |inf_prime_harmonic_prime| |prime_enum_ineq| 0 (|prime_enum_ineq-1| NIL 3941452938 ("" (GRIND) NIL NIL) ((|real_ge_is_total_order| NAME-JUDGEMENT "(total_order?[real])" |real_props| NIL) (|prime?| CONST-DECL "bool" |primes| |ints|) (|real_gt_is_strict_total_order| NAME-JUDGEMENT "(strict_total_order?[real])" |real_props| NIL) (|divides| CONST-DECL "bool" |divides| NIL) (/= CONST-DECL "boolean" |notequal| NIL) (|nat| NONEMPTY-TYPE-EQ-DECL NIL |naturalnumbers| NIL) (|int| NONEMPTY-TYPE-EQ-DECL NIL |integers| NIL) (|integer_pred| CONST-DECL "[rational -> boolean]" |integers| NIL) (|rational| NONEMPTY-TYPE-FROM-DECL NIL |rationals| NIL) (|rational_pred| CONST-DECL "[real -> boolean]" |rationals| NIL) (>= CONST-DECL "bool" |reals| NIL) (|real| NONEMPTY-TYPE-FROM-DECL NIL |reals| NIL) (|real_pred| CONST-DECL "[number_field -> boolean]" |reals| NIL) (|number_field| NONEMPTY-TYPE-FROM-DECL NIL |number_fields| NIL) (|number_field_pred| CONST-DECL "[number -> boolean]" |number_fields| NIL) (|number| NONEMPTY-TYPE-DECL NIL |numbers| NIL) (NOT CONST-DECL "[bool -> bool]" |booleans| NIL) (|bool| NONEMPTY-TYPE-EQ-DECL NIL |booleans| NIL) (|boolean| NONEMPTY-TYPE-DECL NIL |booleans| NIL) (|member| CONST-DECL "bool" |sets| NIL) (|empty?| CONST-DECL "bool" |sets| NIL) (|prime_enumeration| DEF-DECL "int" |inf_prime_harmonic_prime| NIL)) SHOSTAK))("inf_prime_harmonic_prime" |inf_prime_harmonic_prime| |prime_enum_ineq2| 0 (|prime_enum_ineq2-1| NIL 3944658167 ("" (MEASURE-INDUCT "n" "n") (("" (SKEEP) (("" (CASE-REPLACE "x = 0") (("1" (EXPAND "prime_enumeration") (("1" (ASSERT) NIL NIL)) NIL) ("2" (INST -1 "x-1") (("1" (ASSERT) (("1" (PROP) (("1" (CASE "prime_enumeration(x-1) < prime_enumeration(x)") (("1" (ASSERT) NIL NIL) ("2" (HIDE-ALL-BUT (-2 1)) (("2" (NAME-REPLACE "p1" "prime_enumeration(x - 1)") (("2" (EXPAND "prime_enumeration") (("2" (LIFT-IF) (("2" (PROP) (("1" (EXPAND "prime?") (("1" (PROPAX) NIL NIL)) NIL) ("2" (EXPAND "prime?") (("2" (PROPAX) NIL NIL)) NIL) ("3" (EXPAND "prime?") (("3" (PROPAX) NIL NIL)) NIL) ("4" (EXPAND "prime?") (("4" (PROPAX) NIL NIL)) NIL) ("5" (EXPAND "p1") (("5" (TYPEPRED "min({p: (prime?) | p > prime_enumeration(x - 1)})") (("1" (ASSERT) NIL NIL) ("2" (HIDE-ALL-BUT 1) (("2" (SKEEP) (("2" (TYPEPRED "x!1") (("2" (EXPAND "prime?") (("2" (FLATTEN) (("2" (ASSERT) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("3" (EXPAND "nonempty?") (("3" (PROPAX) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (LEMMA "prime_enum_id") (("2" (INST -1 "x-1") (("2" (PROP) (("2" (EXPAND "prime_enumeration" -2) (("2" (PROP) (("1" (EXPAND "prime?") (("1" (PROPAX) NIL NIL)) NIL) ("2" (EXPAND "prime?") (("2" (PROPAX) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (ASSERT) NIL NIL)) NIL)) NIL)) NIL)) NIL) ((|real_ge_is_total_order| NAME-JUDGEMENT "(total_order?[real])" |real_props| NIL) (|int_minus_int_is_int| APPLICATION-JUDGEMENT "int" |integers| NIL) (|x| SKOLEM-CONST-DECL "nat" |inf_prime_harmonic_prime| NIL) (- CONST-DECL "[numfield, numfield -> numfield]" |number_fields| NIL) (|numfield| NONEMPTY-TYPE-EQ-DECL NIL |number_fields| NIL) (> CONST-DECL "bool" |reals| NIL) (|min| CONST-DECL "{a | S(a) AND (FORALL x: S(x) IMPLIES a <= x)}" |min_nat| NIL) (<= CONST-DECL "bool" |reals| NIL) (AND CONST-DECL "[bool, bool -> bool]" |booleans| NIL) (|nonempty?| CONST-DECL "bool" |sets| NIL) (|set| TYPE-EQ-DECL NIL |sets| NIL) (NOT CONST-DECL "[bool -> bool]" |booleans| NIL) (|real_gt_is_strict_total_order| NAME-JUDGEMENT "(strict_total_order?[real])" |real_props| NIL) (|p1| SKOLEM-CONST-DECL "int" |inf_prime_harmonic_prime| NIL) (|prime_enum_id| FORMULA-DECL NIL |inf_prime_harmonic_prime| NIL) (|real_lt_is_strict_total_order| NAME-JUDGEMENT "(strict_total_order?[real])" |real_props| NIL) (= CONST-DECL "[T, T -> boolean]" |equalities| NIL) (IMPLIES CONST-DECL "[bool, bool -> bool]" |booleans| NIL) (|prime?| CONST-DECL "bool" |primes| |ints|) (|prime_enumeration| DEF-DECL "int" |inf_prime_harmonic_prime| NIL) (|wf_nat| FORMULA-DECL NIL |naturalnumbers| NIL) (< CONST-DECL "bool" |reals| NIL) (|naturalnumber| TYPE-EQ-DECL NIL |naturalnumbers| NIL) (|nat| NONEMPTY-TYPE-EQ-DECL NIL |naturalnumbers| NIL) (>= CONST-DECL "bool" |reals| NIL) (|bool| NONEMPTY-TYPE-EQ-DECL NIL |booleans| NIL) (|int| NONEMPTY-TYPE-EQ-DECL NIL |integers| NIL) (|integer_pred| CONST-DECL "[rational -> boolean]" |integers| NIL) (|rational| NONEMPTY-TYPE-FROM-DECL NIL |rationals| NIL) (|rational_pred| CONST-DECL "[real -> boolean]" |rationals| NIL) (|real| NONEMPTY-TYPE-FROM-DECL NIL |reals| NIL) (|real_pred| CONST-DECL "[number_field -> boolean]" |reals| NIL) (|number_field| NONEMPTY-TYPE-FROM-DECL NIL |number_fields| NIL) (|number_field_pred| CONST-DECL "[number -> boolean]" |number_fields| NIL) (|boolean| NONEMPTY-TYPE-DECL NIL |booleans| NIL) (|number| NONEMPTY-TYPE-DECL NIL |numbers| NIL) (|measure_induction| FORMULA-DECL NIL |measure_induction| NIL) (|well_founded?| CONST-DECL "bool" |orders| NIL) (|pred| TYPE-EQ-DECL NIL |defined_types| NIL)) SHOSTAK))("inf_prime_harmonic_prime" |inf_prime_harmonic_prime| |prime_enum_ineq3| 0 (|prime_enum_ineq3-1| NIL 3944816590 ("" (SKEEP) (("" (LEMMA "prime_enum_id") (("" (INST -1 "j") (("" (PROP) (("1" (REPLACES -1) (("1" (EXPAND "prime?") (("1" (FLATTEN) (("1" (ASSERT) NIL NIL)) NIL)) NIL)) NIL) ("2" (CASE "i > j") (("1" (EXPAND ">") (("1" (CASE "FORALL(j:nat): FORALL(i:nat| j < i): prime_enumeration(i) /= 0 AND prime_enumeration(j) /= 0 => prime_enumeration(i) > prime_enumeration(j) ") (("1" (INST -1 "j") (("1" (INST -1 "i") (("1" (PROP) (("1" (ASSERT) NIL NIL) ("2" (EXPAND "prime?") (("2" (FLATTEN) (("2" (ASSERT) NIL NIL)) NIL)) NIL) ("3" (EXPAND "prime?") (("3" (FLATTEN) (("3" (ASSERT) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (HIDE-ALL-BUT 1) (("2" (SKOLEM 1 "b") (("2" (MEASURE-INDUCT "i-b-1" "i") (("2" (SKEEP) (("2" (CASE-REPLACE "x = b+1") (("1" (LEMMA "prime_enum_ineq") (("1" (INST -1 "b") (("1" (ASSERT) NIL NIL)) NIL)) NIL) ("2" (INST -1 "x-1") (("1" (ASSERT) (("1" (PROP) (("1" (LEMMA "prime_enum_ineq") (("1" (INST -1 "x-1") (("1" (ASSERT) NIL NIL)) NIL)) NIL) ("2" (LEMMA "prime_enum_tail_gen") (("2" (INST -1 "x-1") (("2" (ASSERT) (("2" (INST -1 "x") NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (ASSERT) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (ASSERT) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ((|prime_enum_id| FORMULA-DECL NIL |inf_prime_harmonic_prime| NIL) (|prime?| CONST-DECL "bool" |primes| |ints|) (|real_gt_is_strict_total_order| NAME-JUDGEMENT "(strict_total_order?[real])" |real_props| NIL) (|real_le_is_total_order| NAME-JUDGEMENT "(total_order?[real])" |real_props| NIL) (TRUE CONST-DECL "bool" |booleans| NIL) (|wf_nat| FORMULA-DECL NIL |naturalnumbers| NIL) (- CONST-DECL "[numfield, numfield -> numfield]" |number_fields| NIL) (|numfield| NONEMPTY-TYPE-EQ-DECL NIL |number_fields| NIL) (|naturalnumber| TYPE-EQ-DECL NIL |naturalnumbers| NIL) (|measure_induction| FORMULA-DECL NIL |measure_induction| NIL) (|int_minus_int_is_int| APPLICATION-JUDGEMENT "int" |integers| NIL) (|well_founded?| CONST-DECL "bool" |orders| NIL) (|pred| TYPE-EQ-DECL NIL |defined_types| NIL) (|nnint_plus_posint_is_posint| APPLICATION-JUDGEMENT "posint" |integers| NIL) (= CONST-DECL "[T, T -> boolean]" |equalities| NIL) (+ CONST-DECL "[numfield, numfield -> numfield]" |number_fields| NIL) (|prime_enum_ineq| FORMULA-DECL NIL |inf_prime_harmonic_prime| NIL) (|minus_nzint_is_nzint| APPLICATION-JUDGEMENT "nzint" |integers| NIL) (|prime_enum_tail_gen| FORMULA-DECL NIL |inf_prime_harmonic_prime| NIL) (|int_plus_int_is_int| APPLICATION-JUDGEMENT "int" |integers| NIL) (|posint_plus_nnint_is_posint| APPLICATION-JUDGEMENT "posint" |integers| NIL) (|b| SKOLEM-CONST-DECL "nat" |inf_prime_harmonic_prime| NIL) (|x| SKOLEM-CONST-DECL "{i: nat | b < i}" |inf_prime_harmonic_prime| NIL) (|real_ge_is_total_order| NAME-JUDGEMENT "(total_order?[real])" |real_props| NIL) (|real_lt_is_strict_total_order| NAME-JUDGEMENT "(strict_total_order?[real])" |real_props| NIL) (|i| SKOLEM-CONST-DECL "nat" |inf_prime_harmonic_prime| NIL) (|j| SKOLEM-CONST-DECL "nat" |inf_prime_harmonic_prime| NIL) (|prime_enumeration| DEF-DECL "int" |inf_prime_harmonic_prime| NIL) (/= CONST-DECL "boolean" |notequal| NIL) (AND CONST-DECL "[bool, bool -> bool]" |booleans| NIL) (IMPLIES CONST-DECL "[bool, bool -> bool]" |booleans| NIL) (< CONST-DECL "bool" |reals| NIL) (> CONST-DECL "bool" |reals| NIL) (|nat| NONEMPTY-TYPE-EQ-DECL NIL |naturalnumbers| NIL) (>= CONST-DECL "bool" |reals| NIL) (|bool| NONEMPTY-TYPE-EQ-DECL NIL |booleans| NIL) (|int| NONEMPTY-TYPE-EQ-DECL NIL |integers| NIL) (|integer_pred| CONST-DECL "[rational -> boolean]" |integers| NIL) (|rational| NONEMPTY-TYPE-FROM-DECL NIL |rationals| NIL) (|rational_pred| CONST-DECL "[real -> boolean]" |rationals| NIL) (|real| NONEMPTY-TYPE-FROM-DECL NIL |reals| NIL) (|real_pred| CONST-DECL "[number_field -> boolean]" |reals| NIL) (|number_field| NONEMPTY-TYPE-FROM-DECL NIL |number_fields| NIL) (|number_field_pred| CONST-DECL "[number -> boolean]" |number_fields| NIL) (|boolean| NONEMPTY-TYPE-DECL NIL |booleans| NIL) (|number| NONEMPTY-TYPE-DECL NIL |numbers| NIL)) SHOSTAK))("inf_prime_harmonic_prime" |inf_prime_harmonic_prime| |prime_enum_surj_lem_TCC1| 0 (|prime_enum_surj_lem_TCC1-1| NIL 3944899540 ("" (SKEEP) (("" (PROP) (("1" (EXPAND "is_finite") (("1" (INST 1 "n+1" "LAMBDA(i:nat| i <= n): i") (("1" (EXPAND "injective?") (("1" (SKEEP) (("1" (EXPAND "restrict") (("1" (PROPAX) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (EXPAND "empty?") (("2" (INST -1 "2") (("2" (EXPAND "member") (("2" (REWRITE "prime_2") NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ((|number| NONEMPTY-TYPE-DECL NIL |numbers| NIL) (|boolean| NONEMPTY-TYPE-DECL NIL |booleans| NIL) (|number_field_pred| CONST-DECL "[number -> boolean]" |number_fields| NIL) (|number_field| NONEMPTY-TYPE-FROM-DECL NIL |number_fields| NIL) (|real_pred| CONST-DECL "[number_field -> boolean]" |reals| NIL) (|real| NONEMPTY-TYPE-FROM-DECL NIL |reals| NIL) (|rational_pred| CONST-DECL "[real -> boolean]" |rationals| NIL) (|rational| NONEMPTY-TYPE-FROM-DECL NIL |rationals| NIL) (|integer_pred| CONST-DECL "[rational -> boolean]" |integers| NIL) (|int| NONEMPTY-TYPE-EQ-DECL NIL |integers| NIL) (|bool| NONEMPTY-TYPE-EQ-DECL NIL |booleans| NIL) (>= CONST-DECL "bool" |reals| NIL) (|nat| NONEMPTY-TYPE-EQ-DECL NIL |naturalnumbers| NIL) (|numfield| NONEMPTY-TYPE-EQ-DECL NIL |number_fields| NIL) (+ CONST-DECL "[numfield, numfield -> numfield]" |number_fields| NIL) (AND CONST-DECL "[bool, bool -> bool]" |booleans| NIL) (|prime?| CONST-DECL "bool" |primes| |ints|) (<= CONST-DECL "bool" |reals| NIL) (< CONST-DECL "bool" |reals| NIL) (|below| TYPE-EQ-DECL NIL |nat_types| NIL) (|restrict| CONST-DECL "R" |restrict| NIL) (|nnint_plus_posint_is_posint| APPLICATION-JUDGEMENT "posint" |integers| NIL) (|injective?| CONST-DECL "bool" |functions| NIL) (|is_finite| CONST-DECL "bool" |finite_sets| NIL) (|prime_2| FORMULA-DECL NIL |primes| |ints|) (|member| CONST-DECL "bool" |sets| NIL) (|empty?| CONST-DECL "bool" |sets| NIL)) NIL (|prime_enum_surj_lem| SUBTYPE "{p: naturalnumbers.nat | booleans.AND(primes.prime?(p), reals.<=(p, inf_prime_harmonic_prime.n))}" "non_empty_finite_set[nat]")))("inf_prime_harmonic_prime" |inf_prime_harmonic_prime| |prime_enum_surj_lem| 0 (|prime_enum_surj_lem-1| NIL 3944900411 ("" (CASE " FORALL (n: nat | n >= 2):
        is_finite[nat]({p: nat | prime?(p) AND p <= n}) AND
         NOT empty?[nat]({p: nat | prime?(p) AND p <= n})") (("1" (MEASURE-INDUCT "n-2" "n") (("1" (SKEEP) (("1" (CASE-REPLACE "x = 2") (("1" (INST 1 "0") (("1" (EXPAND "prime_enumeration") (("1" (HIDE -1 -2) (("1" (TYPEPRED "max_finite_set_nat.max({p: nat | prime?(p) AND p <= 2})") (("1" (INST -3 "2") (("1" (ASSERT) (("1" (REWRITE "prime_2") NIL NIL)) NIL)) NIL) ("2" (INST -1 "2") NIL NIL)) NIL)) NIL)) NIL)) NIL) ("2" (INST -1 "x-1") (("1" (ASSERT) (("1" (SKEEP) (("1" (NAME-REPLACE "m1" "max_finite_set_nat.max({p: nat | prime?(p) AND p <= x - 1})") (("1" (NAME-REPLACE "m2" "max_finite_set_nat.max({p: nat | prime?(p) AND p <= x})") (("1" (CASE "m1 > m2") (("1" (TYPEPRED "m1") (("1" (TYPEPRED "m2") (("1" (INST -3 "m1") (("1" (ASSERT) NIL NIL)) NIL)) NIL)) NIL) ("2" (CASE "m1 = m2") (("1" (INST 3 "i") (("1" (ASSERT) NIL NIL)) NIL) ("2" (CASE "m1 < m2") (("1" (INST 4 "i+1") (("1" (EXPAND "prime_enumeration" 4) (("1" (LIFT-IF) (("1" (PROP) (("1" (REPLACE -3 -2 :DIR RL) (("1" (TYPEPRED "m2") (("1" (EXPAND "empty?") (("1" (INST -4 "m2") (("1" (EXPAND "member") (("1" (ASSERT) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (TYPEPRED "m1") (("2" (EXPAND "prime?") (("2" (FLATTEN) (("2" (ASSERT) NIL NIL)) NIL)) NIL)) NIL) ("3" (NAME-REPLACE "m3" "min({p: (prime?) | p > prime_enumeration(i)})") (("1" (CASE "m3 < m2") (("1" (CASE-REPLACE "m2 = x") (("1" (TYPEPRED "m1") (("1" (INST -3 "m3") (("1" (TYPEPRED "m3") (("1" (ASSERT) NIL NIL)) NIL) ("2" (TYPEPRED "m3") (("2" (EXPAND "prime?") (("2" (FLATTEN) (("2" (ASSERT) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (CASE "m2 < x") (("1" (TYPEPRED "m1") (("1" (INST -3 "m2") (("1" (ASSERT) NIL NIL)) NIL)) NIL) ("2" (ASSERT) NIL NIL)) NIL)) NIL) ("2" (TYPEPRED "m3") (("2" (INST -3 "m2") (("2" (ASSERT) NIL NIL)) NIL)) NIL)) NIL) ("2" (SKEEP) (("2" (TYPEPRED "x!1") (("2" (EXPAND "prime?") (("2" (FLATTEN) (("2" (ASSERT) NIL NIL)) NIL)) NIL)) NIL)) NIL) ("3" (EXPAND "nonempty?") (("3" (PROPAX) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (ASSERT) NIL NIL)) NIL)) NIL)) NIL) ("2" (INST -2 "x") NIL NIL)) NIL) ("2" (INST -2 "x-1") NIL NIL)) NIL)) NIL)) NIL) ("2" (ASSERT) NIL NIL)) NIL)) NIL)) NIL)) NIL) ("2" (HIDE 2) (("2" (SKEEP) (("2" (PROP) (("1" (EXPAND "is_finite") (("1" (INST 1 "n+1" "LAMBDA(i:nat| i<=n): i") (("1" (EXPAND "injective?") (("1" (SKEEP) (("1" (EXPAND "restrict") (("1" (PROPAX) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (EXPAND "empty?") (("2" (INST -1 "2") (("2" (EXPAND "member") (("2" (REWRITE "prime_2") NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ((|restrict| CONST-DECL "R" |restrict| NIL) (|below| TYPE-EQ-DECL NIL |nat_types| NIL) (|injective?| CONST-DECL "bool" |functions| NIL) (|max| CONST-DECL "{a: nat | S(a) AND (FORALL x: S(x) IMPLIES x <= a)}" |max_finite_set_nat| |ints|) (IMPLIES CONST-DECL "[bool, bool -> bool]" |booleans| NIL) (|finite_set| TYPE-EQ-DECL NIL |finite_sets| NIL) (|non_empty_finite_set| TYPE-EQ-DECL NIL |finite_sets| NIL) (|prime_enumeration| DEF-DECL "int" |inf_prime_harmonic_prime| NIL) (= CONST-DECL "[T, T -> boolean]" |equalities| NIL) (|wf_nat| FORMULA-DECL NIL |naturalnumbers| NIL) (< CONST-DECL "bool" |reals| NIL) (- CONST-DECL "[numfield, numfield -> numfield]" |number_fields| NIL) (|numfield| NONEMPTY-TYPE-EQ-DECL NIL |number_fields| NIL) (|naturalnumber| TYPE-EQ-DECL NIL |naturalnumbers| NIL) (|measure_induction| FORMULA-DECL NIL |measure_induction| NIL) (|int_minus_int_is_int| APPLICATION-JUDGEMENT "int" |integers| NIL) (|well_founded?| CONST-DECL "bool" |orders| NIL) (|pred| TYPE-EQ-DECL NIL |defined_types| NIL) (|real_le_is_total_order| NAME-JUDGEMENT "(total_order?[real])" |real_props| NIL) (|prime_2| FORMULA-DECL NIL |primes| |ints|) (|minus_nzint_is_nzint| APPLICATION-JUDGEMENT "nzint" |integers| NIL) (|real_lt_is_strict_total_order| NAME-JUDGEMENT "(strict_total_order?[real])" |real_props| NIL) (> CONST-DECL "bool" |reals| NIL) (|real_gt_is_strict_total_order| NAME-JUDGEMENT "(strict_total_order?[real])" |real_props| NIL) (|member| CONST-DECL "bool" |sets| NIL) (|i| SKOLEM-CONST-DECL "nat" |inf_prime_harmonic_prime| NIL) (|m3| SKOLEM-CONST-DECL "{a |
   a > prime_enumeration(i) AND
    FORALL (x: (prime?)): x > prime_enumeration(i) IMPLIES a <= x}" |inf_prime_harmonic_prime| NIL) (|min| CONST-DECL "{a | S(a) AND (FORALL x: S(x) IMPLIES a <= x)}" |min_nat| NIL) (|nonempty?| CONST-DECL "bool" |sets| NIL) (+ CONST-DECL "[numfield, numfield -> numfield]" |number_fields| NIL) (|nnint_plus_posint_is_posint| APPLICATION-JUDGEMENT "posint" |integers| NIL) (|x| SKOLEM-CONST-DECL "{n: nat | n >= 2}" |inf_prime_harmonic_prime| NIL) (|real_ge_is_total_order| NAME-JUDGEMENT "(total_order?[real])" |real_props| NIL) (|number| NONEMPTY-TYPE-DECL NIL |numbers| NIL) (|boolean| NONEMPTY-TYPE-DECL NIL |booleans| NIL) (|number_field_pred| CONST-DECL "[number -> boolean]" |number_fields| NIL) (|number_field| NONEMPTY-TYPE-FROM-DECL NIL |number_fields| NIL) (|real_pred| CONST-DECL "[number_field -> boolean]" |reals| NIL) (|real| NONEMPTY-TYPE-FROM-DECL NIL |reals| NIL) (|rational_pred| CONST-DECL "[real -> boolean]" |rationals| NIL) (|rational| NONEMPTY-TYPE-FROM-DECL NIL |rationals| NIL) (|integer_pred| CONST-DECL "[rational -> boolean]" |integers| NIL) (|int| NONEMPTY-TYPE-EQ-DECL NIL |integers| NIL) (|bool| NONEMPTY-TYPE-EQ-DECL NIL |booleans| NIL) (>= CONST-DECL "bool" |reals| NIL) (|nat| NONEMPTY-TYPE-EQ-DECL NIL |naturalnumbers| NIL) (AND CONST-DECL "[bool, bool -> bool]" |booleans| NIL) (|set| TYPE-EQ-DECL NIL |sets| NIL) (|is_finite| CONST-DECL "bool" |finite_sets| NIL) (|prime?| CONST-DECL "bool" |primes| |ints|) (<= CONST-DECL "bool" |reals| NIL) (NOT CONST-DECL "[bool -> bool]" |booleans| NIL) (|empty?| CONST-DECL "bool" |sets| NIL)) SHOSTAK))("inf_prime_harmonic_prime" |inf_prime_harmonic_prime| |prime_enum_inj| 0 (|prime_enum_inj-1| NIL 3945361536 ("" (SKEEP) (("" (LEMMA "prime_enum_ineq3") (("" (INST-CP -1 "i" "j") (("" (INST -1 "j" "i") (("" (ASSERT) NIL NIL)) NIL)) NIL)) NIL)) NIL) ((|prime_enum_ineq3| FORMULA-DECL NIL |inf_prime_harmonic_prime| NIL) (|real_le_is_total_order| NAME-JUDGEMENT "(total_order?[real])" |real_props| NIL) (|nat| NONEMPTY-TYPE-EQ-DECL NIL |naturalnumbers| NIL) (>= CONST-DECL "bool" |reals| NIL) (|bool| NONEMPTY-TYPE-EQ-DECL NIL |booleans| NIL) (|int| NONEMPTY-TYPE-EQ-DECL NIL |integers| NIL) (|integer_pred| CONST-DECL "[rational -> boolean]" |integers| NIL) (|rational| NONEMPTY-TYPE-FROM-DECL NIL |rationals| NIL) (|rational_pred| CONST-DECL "[real -> boolean]" |rationals| NIL) (|real| NONEMPTY-TYPE-FROM-DECL NIL |reals| NIL) (|real_pred| CONST-DECL "[number_field -> boolean]" |reals| NIL) (|number_field| NONEMPTY-TYPE-FROM-DECL NIL |number_fields| NIL) (|number_field_pred| CONST-DECL "[number -> boolean]" |number_fields| NIL) (|boolean| NONEMPTY-TYPE-DECL NIL |booleans| NIL) (|number| NONEMPTY-TYPE-DECL NIL |numbers| NIL)) SHOSTAK))("inf_prime_harmonic_prime" |inf_prime_harmonic_prime| |prime_enum_surj| 0 (|prime_enum_surj-1| NIL 3944899083 ("" (SKEEP) (("" (LEMMA "prime_enum_surj_lem") (("" (INST -1 "p") (("1" (SKEEP) (("1" (NAME-REPLACE "mp" "max_finite_set_nat.max({p_1: nat | prime?(p_1) AND p_1 <= p})") (("1" (TYPEPRED "mp") (("1" (INST -3 "p") (("1" (INST 1 "i") (("1" (ASSERT) NIL NIL)) NIL) ("2" (TYPEPRED "p") (("2" (EXPAND "prime?") (("2" (FLATTEN) (("2" (ASSERT) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (HIDE -1 2) (("2" (PROP) (("1" (EXPAND "is_finite") (("1" (INST 1 "p+1" "LAMBDA(i:nat| i<=p): i") (("1" (EXPAND "injective?") (("1" (SKEEP) (("1" (EXPAND "restrict") (("1" (PROPAX) NIL NIL)) NIL)) NIL)) NIL) ("2" (TYPEPRED "p") (("2" (EXPAND "prime?") (("2" (FLATTEN) (("2" (ASSERT) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (EXPAND "empty?") (("2" (INST -1 "2") (("2" (EXPAND "member") (("2" (REWRITE "prime_2") (("2" (TYPEPRED "p") (("2" (EXPAND "prime?") (("2" (FLATTEN) (("2" (ASSERT) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (TYPEPRED "p") (("2" (EXPAND "prime?") (("2" (FLATTEN) (("2" (ASSERT) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ((|prime_enum_surj_lem| FORMULA-DECL NIL |inf_prime_harmonic_prime| NIL) (|member| CONST-DECL "bool" |sets| NIL) (|prime_2| FORMULA-DECL NIL |primes| |ints|) (|minus_nzint_is_nzint| APPLICATION-JUDGEMENT "nzint" |integers| NIL) (|injective?| CONST-DECL "bool" |functions| NIL) (|restrict| CONST-DECL "R" |restrict| NIL) (|below| TYPE-EQ-DECL NIL |nat_types| NIL) (< CONST-DECL "bool" |reals| NIL) (|numfield| NONEMPTY-TYPE-EQ-DECL NIL |number_fields| NIL) (+ CONST-DECL "[numfield, numfield -> numfield]" |number_fields| NIL) (|int_plus_int_is_int| APPLICATION-JUDGEMENT "int" |integers| NIL) (|real_gt_is_strict_total_order| NAME-JUDGEMENT "(strict_total_order?[real])" |real_props| NIL) (|real_le_is_total_order| NAME-JUDGEMENT "(total_order?[real])" |real_props| NIL) (|max| CONST-DECL "{a: nat | S(a) AND (FORALL x: S(x) IMPLIES x <= a)}" |max_finite_set_nat| |ints|) (<= CONST-DECL "bool" |reals| NIL) (IMPLIES CONST-DECL "[bool, bool -> bool]" |booleans| NIL) (|empty?| CONST-DECL "bool" |sets| NIL) (NOT CONST-DECL "[bool -> bool]" |booleans| NIL) (|finite_set| TYPE-EQ-DECL NIL |finite_sets| NIL) (|is_finite| CONST-DECL "bool" |finite_sets| NIL) (|set| TYPE-EQ-DECL NIL |sets| NIL) (|non_empty_finite_set| TYPE-EQ-DECL NIL |finite_sets| NIL) (= CONST-DECL "[T, T -> boolean]" |equalities| NIL) (|real_ge_is_total_order| NAME-JUDGEMENT "(total_order?[real])" |real_props| NIL) (|boolean| NONEMPTY-TYPE-DECL NIL |booleans| NIL) (|bool| NONEMPTY-TYPE-EQ-DECL NIL |booleans| NIL) (AND CONST-DECL "[bool, bool -> bool]" |booleans| NIL) (|number| NONEMPTY-TYPE-DECL NIL |numbers| NIL) (|number_field_pred| CONST-DECL "[number -> boolean]" |number_fields| NIL) (|number_field| NONEMPTY-TYPE-FROM-DECL NIL |number_fields| NIL) (|real_pred| CONST-DECL "[number_field -> boolean]" |reals| NIL) (|real| NONEMPTY-TYPE-FROM-DECL NIL |reals| NIL) (>= CONST-DECL "bool" |reals| NIL) (|rational_pred| CONST-DECL "[real -> boolean]" |rationals| NIL) (|rational| NONEMPTY-TYPE-FROM-DECL NIL |rationals| NIL) (|integer_pred| CONST-DECL "[rational -> boolean]" |integers| NIL) (|int| NONEMPTY-TYPE-EQ-DECL NIL |integers| NIL) (|prime?| CONST-DECL "bool" |primes| |ints|) (|p| SKOLEM-CONST-DECL "(prime?)" |inf_prime_harmonic_prime| NIL) (|nat| NONEMPTY-TYPE-EQ-DECL NIL |naturalnumbers| NIL)) SHOSTAK))("finseq_rel_prime" |finseq_rel_prime| |lcm_div_TCC1| 0 (|lcm_div_TCC1-1| |nil| 3784467106 ("" (SUBTYPE-TCC) NIL NIL) ((|divides| |const-decl| "bool" |divides| NIL)) NIL (|lcm_div| SUBTYPE "finseq_rel_prime.b" "{jj: integers.int | booleans.=>(finseq_rel_prime.a = 0, jj /= 0)}")))("finseq_rel_prime" |finseq_rel_prime| |lcm_div_TCC2| 0 (|lcm_div_TCC2-1| |nil| 3784467106 ("" (SKOSIMP) (("" (REPLACES -1) (("" (LEMMA "gcd_divides") (("" (INST?) (("" (PROP) (("" (EXPAND "divides") (("" (SKOSIMP*) (("" (LEMMA "div_simple") (("" (INST?) (("" (ASSERT) (("" (IFF) (("" (PROP) (("" (HIDE (1 5)) (("" (INST 1 "gcd(a!1, b!1) * x!1 * x!2") (("" (ASSERT) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ((|posint_times_posint_is_posint| |application-judgement| "posint" |integers| NIL) (TRUE |const-decl| "bool" |booleans| NIL) (|bool| |nonempty-type-eq-decl| NIL |booleans| NIL) (|boolean| |nonempty-type-decl| NIL |booleans| NIL) (|number| |nonempty-type-decl| NIL |numbers| NIL) (|number_field_pred| |const-decl| "[number -> boolean]" |number_fields| NIL) (|number_field| |nonempty-type-from-decl| NIL |number_fields| NIL) (|real_pred| |const-decl| "[number_field -> boolean]" |reals| NIL) (|real| |nonempty-type-from-decl| NIL |reals| NIL) (|rational_pred| |const-decl| "[real -> boolean]" |rationals| NIL) (|rational| |nonempty-type-from-decl| NIL |rationals| NIL) (|integer_pred| |const-decl| "[rational -> boolean]" |integers| NIL) (|int| |nonempty-type-eq-decl| NIL |integers| NIL) (>= |const-decl| "bool" |reals| NIL) (|nonneg_int| |nonempty-type-eq-decl| NIL |integers| NIL) (> |const-decl| "bool" |reals| NIL) (|posnat| |nonempty-type-eq-decl| NIL |integers| NIL) (|divides| |const-decl| "bool" |divides| NIL) (|div_simple| |formula-decl| NIL |integer_props| NIL) (|int_times_int_is_int| |application-judgement| "int" |integers| NIL) (|posrat_div_posrat_is_posrat| |application-judgement| "posrat" |rationals| NIL) (|gcd| |const-decl| "{k: posnat | divides(k, i) AND divides(k, j)}" |gcd| |ints|) (AND |const-decl| "[bool, bool -> bool]" |booleans| NIL) (= |const-decl| "[T, T -> boolean]" |equalities| NIL) (IMPLIES |const-decl| "[bool, bool -> bool]" |booleans| NIL) (|nzint| |nonempty-type-eq-decl| NIL |integers| NIL) (/= |const-decl| "boolean" |notequal| NIL) (* |const-decl| "[numfield, numfield -> numfield]" |number_fields| NIL) (|numfield| |nonempty-type-eq-decl| NIL |number_fields| NIL) (|gcd_divides| |formula-decl| NIL |gcd| |ints|)) NIL (|lcm_div| SUBTYPE "number_fields./(number_fields.*(finseq_rel_prime.a, finseq_rel_prime.b), finseq_rel_prime.d)" "int")))("finseq_rel_prime" |finseq_rel_prime| |lcm_div| 0 (|lcm_div-1| |nil| 3784467107 ("" (SKOSIMP) (("" (LEMMA "gcd_divides") (("" (INST?) (("" (PROP) (("" (EXPAND "divides") (("" (SKOSIMP*) (("" (REPLACE -5 (-1 -2) RL) (("" (REPLACE -1 -3) (("" (REPLACE -2 -4) (("" (LEMMA "div_cancel4") (("" (INST-CP -1 "d!1" "x!1" "a!1") (("" (INST-CP -1 "d!1" "x!2" "b!1") (("" (INST-CP -1 "d!1" "x!1 * x!3" "c!1") (("" (INST -1 "d!1" "x!2 * x!4" "c!1") (("" (PROP) (("1" (HIDE (-2 -4 -6 -8)) (("1" (REPLACE -3 -4 RL) (("1" (HIDE -3) (("1" (LEMMA "gcd_div_by_gcd") (("1" (INST -1 "a!1" "b!1") (("1" (EXPAND "div_by_gcd") (("1" (LEMMA "gcd_sym") (("1" (INST?) (("1" (ASSERT) (("1" (REPLACE -1 -2 RL) (("1" (HIDE -1) (("1" (REPLACE -9 -1 RL) (("1" (REPLACE -2 -1 RL) (("1" (REPLACE -3 -1 RL) (("1" (LEMMA "rel_prime_div_prod") (("1" (INST -1 "x!1" "x!2" "x!4") (("1" (ASSERT) (("1" (EXPAND "rel_prime") (("1" (PROP) (("1" (EXPAND "divides") (("1" (SKOSIMP) (("1" (REPLACE -1 -9) (("1" (REPLACE -3 -9) (("1" (REPLACE -4 -9) (("1" (INST 3 "x!5") (("1" (ASSERT) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (HIDE-ALL-BUT (-4 1 2 3)) (("2" (EXPAND "divides") (("2" (INST?) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (ASSERT) NIL NIL) ("3" (ASSERT) NIL NIL) ("4" (ASSERT) NIL NIL) ("5" (ASSERT) NIL NIL) ("6" (ASSERT) NIL NIL) ("7" (ASSERT) NIL NIL) ("8" (ASSERT) NIL NIL) ("9" (ASSERT) NIL NIL) ("10" (ASSERT) NIL NIL) ("11" (ASSERT) NIL NIL) ("12" (ASSERT) NIL NIL) ("13" (ASSERT) NIL NIL) ("14" (ASSERT) NIL NIL) ("15" (ASSERT) NIL NIL) ("16" (ASSERT) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ((|gcd_divides| |formula-decl| NIL |gcd| |ints|) (|div_cancel4| |formula-decl| NIL |real_props| NIL) (|rat_div_nzrat_is_rat| |application-judgement| "rat" |rationals| NIL) (|posint| |nonempty-type-eq-decl| NIL |integers| NIL) (|gcd_sym| |formula-decl| NIL |gcd| |ints|) (|rel_prime_div_prod| |formula-decl| NIL |gcd| |ints|) (|posrat_times_posrat_is_posrat| |application-judgement| "posrat" |rationals| NIL) (|rat_times_rat_is_rat| |application-judgement| "rat" |rationals| NIL) (|rel_prime| |const-decl| "bool" |gcd| |ints|) (|div_by_gcd| |const-decl| "posint" |gcd_fractions| |ints|) (|gcd_div_by_gcd| |formula-decl| NIL |gcd_fractions| |ints|) (|numfield| |nonempty-type-eq-decl| NIL |number_fields| NIL) (* |const-decl| "[numfield, numfield -> numfield]" |number_fields| NIL) (/= |const-decl| "boolean" |notequal| NIL) (|nonzero_real| |nonempty-type-eq-decl| NIL |reals| NIL) NIL (|posrat_div_posrat_is_posrat| |application-judgement| "posrat" |rationals| NIL) (|mult_divides2| |application-judgement| "(divides(m))" |divides| NIL) (|mult_divides1| |application-judgement| "(divides(n))" |divides| NIL) (|posint_times_posint_is_posint| |application-judgement| "posint" |integers| NIL) (|posnat| |nonempty-type-eq-decl| NIL |integers| NIL) (> |const-decl| "bool" |reals| NIL) (|nonneg_int| |nonempty-type-eq-decl| NIL |integers| NIL) (>= |const-decl| "bool" |reals| NIL) (|bool| |nonempty-type-eq-decl| NIL |booleans| NIL) (|int| |nonempty-type-eq-decl| NIL |integers| NIL) (|integer_pred| |const-decl| "[rational -> boolean]" |integers| NIL) (|rational| |nonempty-type-from-decl| NIL |rationals| NIL) (|rational_pred| |const-decl| "[real -> boolean]" |rationals| NIL) (|real| |nonempty-type-from-decl| NIL |reals| NIL) (|real_pred| |const-decl| "[number_field -> boolean]" |reals| NIL) (|number_field| |nonempty-type-from-decl| NIL |number_fields| NIL) (|number_field_pred| |const-decl| "[number -> boolean]" |number_fields| NIL) (|boolean| |nonempty-type-decl| NIL |booleans| NIL) (|number| |nonempty-type-decl| NIL |numbers| NIL)) SHOSTAK))("finseq_rel_prime" |finseq_rel_prime| |primes_lcm_div_TCC1| 0 (|primes_lcm_div_TCC1-1| |nil| 3784478063 ("" (SUBTYPE-TCC) NIL NIL) NIL NIL (|primes_lcm_div| SUBTYPE "finseq_rel_prime.b" "{jj: integers.int | booleans.=>(finseq_rel_prime.a = 0, jj /= 0)}")))("finseq_rel_prime" |finseq_rel_prime| |primes_lcm_div| 0 (|primes_lcm_div-1| |nil| 3784478064 ("" (SKOSIMP) (("" (EXPAND "rel_prime") (("" (LEMMA "lcm_div") (("" (INST -1 "a!1" "b!1" "c!1" "gcd(a!1, b!1)") (("" (ASSERT) NIL NIL)) NIL)) NIL)) NIL)) NIL) ((|rel_prime| |const-decl| "bool" |gcd| |ints|) (|number| |nonempty-type-decl| NIL |numbers| NIL) (|boolean| |nonempty-type-decl| NIL |booleans| NIL) (|number_field_pred| |const-decl| "[number -> boolean]" |number_fields| NIL) (|number_field| |nonempty-type-from-decl| NIL |number_fields| NIL) (|real_pred| |const-decl| "[number_field -> boolean]" |reals| NIL) (|real| |nonempty-type-from-decl| NIL |reals| NIL) (|rational_pred| |const-decl| "[real -> boolean]" |rationals| NIL) (|rational| |nonempty-type-from-decl| NIL |rationals| NIL) (|integer_pred| |const-decl| "[rational -> boolean]" |integers| NIL) (|int| |nonempty-type-eq-decl| NIL |integers| NIL) (|bool| |nonempty-type-eq-decl| NIL |booleans| NIL) (>= |const-decl| "bool" |reals| NIL) (|nonneg_int| |nonempty-type-eq-decl| NIL |integers| NIL) (> |const-decl| "bool" |reals| NIL) (|posnat| |nonempty-type-eq-decl| NIL |integers| NIL) (IMPLIES |const-decl| "[bool, bool -> bool]" |booleans| NIL) (= |const-decl| "[T, T -> boolean]" |equalities| NIL) (/= |const-decl| "boolean" |notequal| NIL) (AND |const-decl| "[bool, bool -> bool]" |booleans| NIL) NIL (|gcd| |const-decl| "{k: posnat | divides(k, i) AND divides(k, j)}" |gcd| |ints|) (|posint_times_posint_is_posint| |application-judgement| "posint" |integers| NIL) (|mult_divides1| |application-judgement| "(divides(n))" |divides| NIL) (|mult_divides2| |application-judgement| "(divides(m))" |divides| NIL) (|lcm_div| |formula-decl| NIL |finseq_rel_prime| NIL)) SHOSTAK))